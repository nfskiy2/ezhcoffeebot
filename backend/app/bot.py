import logging
import os
import re
import asyncio

# –ò–º–ø–æ—Ä—Ç—ã –∏–∑ python-telegram-bot
from telegram import (
    Update, WebAppInfo, Message, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice, Bot
)
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, PreCheckoutQueryHandler, CallbackContext
)
from telegram.error import TelegramError # –î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ Telegram API

# –ü–æ–ª—É—á–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
BOT_TOKEN = os.getenv('BOT_TOKEN')
PAYMENT_PROVIDER_TOKEN = os.getenv('PAYMENT_PROVIDER_TOKEN')
WEBHOOK_URL = os.getenv('WEBHOOK_URL') # URL, –≥–¥–µ –∑–∞–ø—É—â–µ–Ω FastAPI (–¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤–µ–±—Ö—É–∫–∞)
WEBHOOK_PATH = '/bot' # –ü—É—Ç—å –≤–µ–±—Ö—É–∫–∞ –Ω–∞ FastAPI
APP_URL = os.getenv('APP_URL') # URL –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –∫–Ω–æ–ø–∫–∏

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Application –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤
# –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–µ—Ç –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Application, –Ω–æ –Ω–µ —É–ø—Ä–∞–≤–ª—è–µ—Ç –µ–≥–æ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º (polling/webhook)
async def initialize_bot_app() -> Application: # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ –≤ initialize_bot_app
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Telegram Bot –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç —Ö–µ–Ω–¥–ª–µ—Ä—ã."""
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN is not set! Bot will not work.")
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º Application –±–µ–∑ —Ç–æ–∫–µ–Ω–∞; –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ API-–≤—ã–∑–æ–≤–æ–≤ —É–ø–∞–¥—É—Ç.
        return Application.builder().build()

    application_instance = Application.builder().token(BOT_TOKEN).build()

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ö–µ–Ω–¥–ª–µ—Ä–æ–≤. –û–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç context.bot
    application_instance.add_handler(MessageHandler(filters.SuccessfulPayment(), handle_successful_payment))
    application_instance.add_handler(PreCheckoutQueryHandler(handle_pre_checkout_query))
    application_instance.add_handler(CommandHandler("start", handle_start_command))
    application_instance.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_all_messages))

    logger.info("Telegram Bot handlers registered on Application object.")
    return application_instance

# –£–î–ê–õ–ï–ù–´ –ì–õ–û–ë–ê–õ–¨–ù–´–ï application –∏ bot_instance –∏–∑ —ç—Ç–æ–≥–æ —Ñ–∞–π–ª–∞.
# –û–Ω–∏ –±—É–¥—É—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –∏ —É–ø—Ä–∞–≤–ª—è—Ç—å—Å—è –≤ main.py.


# --- –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏-—Ö–µ–Ω–¥–ª–µ—Ä—ã –±–æ—Ç–∞ ---
# –û–Ω–∏ –ø—Ä–∏–Ω–∏–º–∞—é—Ç `update` –∏ `context`. `context.bot` –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –¥–æ—Å—Ç—É–ø –∫ —ç–∫–∑–µ–º–ø–ª—è—Ä—É Bot.

async def handle_successful_payment(update: Update, context: CallbackContext) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞."""
    if not update.message or not update.message.successful_payment or not update.effective_chat:
        logger.warning("Received successful payment update with missing data.")
        return

    logger.info(f"Received successful payment from chat_id: {update.effective_chat.id}")
    user_name = update.message.successful_payment.order_info.name or "Friend"
    text = f'–°–ø–∞—Å–∏–±–æ –∑–∞ –≤–∞—à –∑–∞–∫–∞–∑, *{user_name}*! –≠—Ç–æ –Ω–µ –Ω–∞—Å—Ç–æ—è—â–µ–µ –∫–∞—Ñ–µ, —Ç–∞–∫ —á—Ç–æ –≤–∞—à–∞ –∫–∞—Ä—Ç–∞ –Ω–µ –±—ã–ª–∞ —Å–ø–∏—Å–∞–Ω–∞.\n\n–•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è üôÇ'
    try:
        await context.bot.send_message( # –ò—Å–ø–æ–ª—å–∑—É–µ–º context.bot
            chat_id=update.effective_chat.id,
            text=text,
            parse_mode='Markdown'
        )
    except TelegramError as e:
        logger.error(f"Failed to send success message: {e}")


async def handle_pre_checkout_query(update: Update, context: CallbackContext) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ Pre-Checkout –∑–∞–ø—Ä–æ—Å–∞."""
    if not update.pre_checkout_query:
         logger.warning("Received pre-checkout query update with missing data.")
         return

    query_id = update.pre_checkout_query.id
    user_id = update.pre_checkout_query.from_user.id
    logger.info(f"Received pre-checkout query (ID: {query_id}) from user_id: {user_id}")

    try:
        start_time = asyncio.get_event_loop().time() # –ó–∞—Å–µ–∫–∞–µ–º –≤—Ä–µ–º—è
        await update.pre_checkout_query.answer(ok=True)
        end_time = asyncio.get_event_loop().time() # –ó–∞—Å–µ–∫–∞–µ–º –≤—Ä–µ–º—è
        logger.info(f"Answered pre-checkout query (ID: {query_id}) successfully in {end_time - start_time:.3f} seconds.")
    except TelegramError as e:
        logger.error(f"Failed to answer pre-checkout query (ID: {query_id}): {e}")
        # –í–æ–∑–º–æ–∂–Ω–æ, –∑–¥–µ—Å—å —Å—Ç–æ–∏—Ç –¥–æ–±–∞–≤–∏—Ç—å –Ω–µ–±–æ–ª—å—à—É—é –∑–∞–¥–µ—Ä–∂–∫—É –ø–µ—Ä–µ–¥ retry –∏–ª–∏ logging.
        # –ù–æ –¥–ª—è PreCheckoutQuery, –µ—Å–ª–∏ –ø–µ—Ä–≤—ã–π —Ä–∞–∑ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, —Ç–æ –≤—Ç–æ—Ä–æ–π —Ä–∞–∑ —É–∂–µ –Ω–µ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª–∞
        # —Ç.–∫. Telegram —É–∂–µ –æ—Ç–º–µ–Ω–∏–ª.
    except Exception as e:
        logger.error(f"Unexpected error answering pre-checkout query (ID: {query_id}): {e}")



async def handle_start_command(update: Update, context: CallbackContext) -> None:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start."""
    if not update.effective_chat:
        logger.warning("Received start command update with missing chat data.")
        return

    logger.info(f"Received start command from chat_id: {update.effective_chat.id}")
    # –ü–µ—Ä–µ–¥–∞–µ–º context.bot —è–≤–Ω–æ –≤ send_actionable_message
    await send_actionable_message(
        chat_id=update.effective_chat.id,
        text='*–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Laurel Cafe!* üåø\n\n–ü–æ—Ä–∞ –∑–∞–∫–∞–∑–∞—Ç—å —á—Ç–æ-–Ω–∏–±—É–¥—å –≤–∫—É—Å–Ω–µ–Ω—å–∫–æ–µ üòã –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å.',
        bot_instance=context.bot # –ü–µ—Ä–µ–¥–∞–µ–º Bot
    )


async def handle_all_messages(update: Update, context: CallbackContext) -> None:
    """Fallback —Ö–µ–Ω–¥–ª–µ—Ä –¥–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π."""
    if not update.effective_chat or not update.message or not update.message.text:
        logger.warning("Received text message update with missing data.")
        return

    logger.info(f"Received text message from chat_id: {update.effective_chat.id}: {update.message.text}")
    # –ü–µ—Ä–µ–¥–∞–µ–º context.bot —è–≤–Ω–æ –≤ send_actionable_message
    await send_actionable_message(
        chat_id=update.effective_chat.id,
        text="–ß–µ—Å—Ç–Ω–æ –≥–æ–≤–æ—Ä—è, —è –Ω–µ –∑–Ω–∞—é, –∫–∞–∫ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏—è. –ù–æ –º–æ–≥—É –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –≤–∞–º –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –Ω–∞—à–∏–º –º–µ–Ω—é. –£–≤–µ—Ä–µ–Ω, –≤—ã –Ω–∞–π–¥–µ—Ç–µ —á—Ç–æ-—Ç–æ –ø–æ –≤–∫—É—Å—É! üòâ",
        bot_instance=context.bot # –ü–µ—Ä–µ–¥–∞–µ–º Bot
    )


# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–æ—Ç–∞ ---
# –¢–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç bot_instance —è–≤–Ω–æ
async def send_actionable_message(chat_id: int, text: str, bot_instance: Bot) -> None:
    """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–Ω–æ–ø–∫–æ–π Mini App."""
    if bot_instance is None:
        logger.error("Bot instance is not provided to send_actionable_message!")
        return

    if not APP_URL:
        logger.warning("APP_URL is not set. Cannot send actionable message with Mini App button.")
        try:
             await bot_instance.send_message(chat_id=chat_id, text=text, parse_mode='Markdown')
        except TelegramError as e:
            logger.error(f"Failed to send basic message: {e}")
        return

    markup = InlineKeyboardMarkup([
        [InlineKeyboardButton("–ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç—å –º–µ–Ω—é", web_app=WebAppInfo(url=APP_URL))]
    ])
    try:
        await bot_instance.send_message(
            chat_id=chat_id,
            text=text,
            parse_mode='Markdown',
            reply_markup=markup
        )
    except TelegramError as e:
        logger.error(f"Failed to send actionable message: {e}")


# --- –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ –Ω–∞ –∏–Ω–≤–æ–π—Å (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ FastAPI) ---
# –¢–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç bot_instance —è–≤–Ω–æ
def create_invoice_link(prices: list[LabeledPrice], bot_instance: Bot) -> str | None:
    """–°–æ–∑–¥–∞–Ω–∏–µ —Å—Å—ã–ª–∫–∏ –Ω–∞ –∏–Ω–≤–æ–π—Å –¥–ª—è –æ–ø–ª–∞—Ç—ã. –í—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ FastAPI."""
    if bot_instance is None:
        logger.error("Bot instance is not provided to create_invoice_link! Cannot create invoice link.")
        return None

    if not PAYMENT_PROVIDER_TOKEN:
         logger.error("PAYMENT_PROVIDER_TOKEN is not set! Cannot create invoice link.")
         return None
    
    logger.info(f"Attempting to create invoice link.")
    logger.info(f"PAYMENT_PROVIDER_TOKEN being used: {PAYMENT_PROVIDER_TOKEN}")
    logger.info(f"Prices being sent: {[p.to_dict() for p in prices]}") # –î–ª—è –Ω–∞–≥–ª—è–¥–Ω–æ—Å—Ç–∏, –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º LabeledPrice –≤ dict

    try:
        return bot_instance.create_invoice_link(
            title='–ó–∞–∫–∞–∑ #1',
            description='–û—Ç–ª–∏—á–Ω—ã–π –≤—ã–±–æ—Ä! –ï—â–µ –ø–∞—Ä–∞ —à–∞–≥–æ–≤, –∏ –ø—Ä–∏—Å—Ç—É–ø–∏–º –∫ –≥–æ—Ç–æ–≤–∫–µ ;)',
            payload='orderID',
            provider_token=PAYMENT_PROVIDER_TOKEN,
            currency='RUB',
            prices=prices,
            need_name=True,
            need_phone_number=True,
            need_shipping_address=True,
        )
    except TelegramError as e:
        logger.error(f"Failed to create invoice link: {e}")
        return None


# --- –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤–µ–±—Ö—É–∫–∞ (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∏–∑ FastAPI startup event) ---
# –¢–µ–ø–µ—Ä—å –ø—Ä–∏–Ω–∏–º–∞–µ—Ç application_instance —è–≤–Ω–æ
async def setup_webhook(application_instance: Application) -> None:
    """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤–µ–±—Ö—É–∫ –±–æ—Ç–∞, –µ—Å–ª–∏ WEBHOOK_URL –∏ WEBHOOK_PATH –∑–∞–¥–∞–Ω—ã."""
    if application_instance is None:
        logger.error("Bot application is not provided to setup_webhook! Cannot set webhook.")
        return

    if not WEBHOOK_URL or not WEBHOOK_PATH:
        logger.warning("WEBHOOK_URL or WEBHOOK_PATH not set. Webhook not configured.")
        return

    full_webhook_url = WEBHOOK_URL + WEBHOOK_PATH
    try:
        await application_instance.bot.set_webhook(url=full_webhook_url)
        logger.info(f"Webhook set to {full_webhook_url}")
    except TelegramError as e:
        logger.error(f"Failed to set webhook to {full_webhook_url}: {e}")
    except Exception as e:
        logger.error(f"An unexpected error occurred while setting webhook: {e}")